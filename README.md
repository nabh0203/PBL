# 전주대학교 실감미디어 미디어파사드 PBL 프로젝트
![image 104](https://github.com/user-attachments/assets/8db704a7-e2eb-4006-9758-d241610a1efd)

**사용 기술**

- Unity
- C#
- NDI 5 

## PBL 그리고 Void*

> **진로와 관련된 분야라면 “무엇이든(Void&ast;)” 가능한**
> 
> 여름 계절 학기 전주대학교 주최로 진행하였던 **실감 미디어 파사드 PBL 프로젝트**입니다.
>
> c, c++ 언어에서 **generic 포인터**로 알려진 **Void***는 굉장히 특별한 타입입니다.
>
> **”그 어떤 타입이든 객체든 가리킬 수 있는 포인터”** 의 의미를 가진 함수이며
>
> 다르게 해석하면 ***“무엇이든”*** 이라는 의미를 가진 함수라고 생각합니다.
> 
> 해당 프로젝트에 개발자로 참여함으로써 VR 콘텐츠만이 아닌 진로와 관련된 분야라면
> 
>***“무엇이든 가능하다”***  라는 자신감을 내비칠 수 있게 해준 콘텐츠입니다.


## 미디어 파사드를 활용한 콘텐츠
![스크린샷 2024-04-04 003301](https://github.com/user-attachments/assets/21cf60bd-f40f-4cb5-a247-9e46b52b3b64)

>**미디어(media)** 와 건물의 외벽을 뜻하는 **파사드(facade)** 가 합성된 용어로, 건물의 외벽에 다양한 콘텐츠 영상을 투사 하는 것을 뜻합니다.
>
>저희는 미디어 파사드를 이용하여 보는 사람들에게 실감형 콘텐츠를 제공하였습니다.

---
## 3°C 그리고 3가지 게임 구성

**지구의 온도가 3°C 만 오르면 온 세상은 물에 잠기게 된다.**

> 이번 프로젝트의 중점 키워드인 **“기후위기”** 와 *“**지구의 온도가 현재 온도보다
3°C 만 올라가기만 해도 지구는 물에 잠긴다”***  라는 문장을 연결지어
총 3가지의 게임을 제작하였으며 사용자는 게임에서 이기면 1도가 올라가게 되고 지게되면 온도가 올라가지 않는 기획을 구성 하였습니다.

먼저 첫번째 게임같은 경우에는 ***“꿀벌이 지구에서 사라지게 된다면 자연생태계는
망가지게 된다”***  라는 문장을 첫번쨰 게임의 컨셉으로 잡았습니다.
**인간들의 무자비한 쓰레기 투기로 인해 자연이 훼손되며 자연스레 꿀벌의 개채수는 줄어들게 된다** 라는 점을 중점으로 제작하였습니다.

두번째 게임의 주제는 ***“자동차의 매연가스”*** 입니다. 
**자동차의 매연이나 공장에서 나오는 매연들이 하늘로 올라가 독성구름을 만들어 오존층을 파괴하고 산성비를 만들어 피해를 준다** 라는 내용을 컨셉으로 잡아 
제작하였습니다.

세번쨰 게임의 주제는 **“나무”** 입니다.
**인간들의 무자비한 지역개발로 인해 나무들이 훼손되고 사라지면서 자연이 점점 사라지게 된다** 라는 점을 컨셉으로 잡아 제작하였습니다.
> 
</aside>

![KakaoTalk_20230712_154807787_14.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/ce9a784e-39da-4c88-b8b7-83d5a9b7cf68/KakaoTalk_20230712_154807787_14.jpg)

1. **꿀벌 게임**

![1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/20b389ce-ef65-4cd1-9259-5d49604153b9/1.png)

![IMG_3715.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/e99d25f5-117c-4620-b9d2-2790a5235f58/IMG_3715.png)

1. **팩맨 게임(자동차)**

![2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/8bfe8349-db78-4e37-99d6-0e8686ace7e8/2.png)

![나무.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/4e0e6f45-541f-492e-983c-ea70d9dc0306/%E1%84%82%E1%85%A1%E1%84%86%E1%85%AE.png)

1. **갤러그 게임(나무)**

![3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/cdfbad48-dc95-408e-90ae-502307384ee4/3.png)

# $\Large\bf{개발~목표}$

<aside>
<img src="/icons/school_gray.svg" alt="/icons/school_gray.svg" width="40px" /> **건국대학교**

> 해당 프로젝트는 원래 전주대학교에서 진행될 예정이었으나 같은 산업협력단체에 
속해있는 **건국대학교 서울캠퍼스** 에서 미디어 파사드를 진행했습니다.

먼저 **노천극장 건물**인 **학생회관 외벽** 에 미디어를 송출하여야 한다는 점에서
너무나도 큰 난관에 봉착 했습니다. 더군다나 영상이 아닌 게임으로 제작을 하는데
있어서 개발을 할수 있는 인원이 저 혼자였고 3일이라는 시간안에 결과물을 
송출하여 관객들에게 체험을 선사해야 하는 점이 문제점이었습니다
> 
</aside>

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **1인 개발**

> 미디어 파사드 프로젝트는 완성된 영상을 외벽에 송출해 사람들에게 선보이는 
것이 일반적입니다.
> 
> 
> 하지만 영상을 게임 형태로 제작해 실시간으로 체험할 수 있게 하는 아이디어는 
> 리스크가 크고, 게임 개발이 가능한 인원이 저 혼자여서 프로젝트의 성공 여부가 
> 온전히 저에게 달려있었습니다.
> 
> 팀원들과 논의한 주요 내용은 라이브 방식으로 사람들에게 체험 기회를 **어떻게 제공할지** 에 대한 것이었습니다. 
> 
> 다른 팀들은 영상물을 제작해 빔 프로젝터를 통해 송출하는 것으로 작업을 마무리
> 하지만, 저희 작업물은 라이브 송출을 위해 극복해야 할 많은 단계가 있었습니다. 
> 
> 결국 멘토님과 상의 끝에 **NDI 5**라는 프로그램을 통해 게임을 송출할 수 있게 
> 되었습니다. ****
> 
> **NDI 5**의 화면 캡처 기능을 활용해 외벽을 모니터로 사용하여 게임을 송출하고, 
> 키보드를 통해 이를 체험할 수 있도록 기획했습니다.
> 
> 제한된 시간, 단 3일만에 프로젝트를 완성해야 했기에, 시간적 여유가 없었습니다. 
> 
> 이에 기존에 존재하는 고전 게임들을 참고하여 게임을 제작하기로 결정했습니다. 
> 
> 결국, **“갤러그”**와 **“팩맨”**의 게임 로직을 차용하여 새로운 게임을 제작했습니다.
> 
</aside>

![PBL3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/1fc01dc6-3f9e-41ac-8496-be6c366dc883/PBL3.png)

![PBL4.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/458c9a98-0e25-4af7-8c70-8ca5891c3f48/PBL4.png)

![PBL1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/0b1e4c09-2931-4610-bb1e-2888cd296179/PBL1.png)

# $\Large\bf{개발과정}$

![스크린샷(429).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/f3943019-a2d9-4708-a6f7-962bd2933858/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(429).png)

**자동차 팩맨 게임 ⬆️**

![스크린샷(431).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/cdb43cbb-2870-453f-9b26-aa1468ecfce5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(431).png)

**나무 갤러그 게임 ⬆️**

<aside>
<img src="/icons/video-game-classic_gray.svg" alt="/icons/video-game-classic_gray.svg" width="40px" /> **UI**

> 제작한 게임의 **UI 비주얼** 입니다.
디자인 부분은 도트그래픽과 같은 느낌을 사용하여 최대한 고전게임의 느낌이 나게 제작하였으며 조작은 간단하게 방향키를 사용하여 플레이할수 있게 설정하였습니다.

고전게임인 **“Packman”** , **“Galaga”** 의 로직을 참고하여 제작하였으며 **Timer** 를
설정하여 제한시간내에 게임을 클리어 하여 “**Win”** , “**Lose”** **Scene** 으로 
이동할수 있게 제작하였습니다.
> 
</aside>

### $\large\bf{Scripts}$

### GameMaster

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class GameMaster : MonoBehaviour
{
    public AudioSource Audio;
    public AudioClip BGM;
    public Text timerText;
    public List<GameObject> Dots = new List<GameObject>();
    public string Scenename;
    public GameObject Oil1;
    public GameObject Oil2;
    public GameObject Oil3;
    public GameObject Oil4;
    private float timeLeft = 50f;
    private bool isPaused = false;

    void Start()
    {
        StartCoroutine(WaitForSceneSwitch());
        Audio.PlayOneShot(BGM);
    }

    void Update()
    {
        UpdateTimer();

        if (!isPaused) 
        {
            CheckDotsRemaining();
        }
    }

    IEnumerator WaitForSceneSwitch()
    {
        yield return new WaitForSeconds(50f);
        SceneManager.LoadScene(Scenename);
    }

    void UpdateTimer()
    {
        timeLeft -= Time.deltaTime;
        if (timeLeft <= 0)
        {
            timeLeft = 0;
        }

        int minutes = (int)(timeLeft / 60);
        int seconds = (int)(timeLeft % 60);
        timerText.text = $"{minutes:00}:{seconds:00}";
    }

    void CheckDotsRemaining()
    {
        GameObject[] remainingDots = GameObject.FindGameObjectsWithTag("dot");
        if (remainingDots.Length == 64)
        {
            Oil1.SetActive(true);
        }
        else if (remainingDots.Length == 60)
        {
            Oil2.SetActive(true);
        }
        else if (remainingDots.Length == 40)
        {
            Oil3.SetActive(true);
        }
        else if (remainingDots.Length == 20)
        {
            Oil4.SetActive(true);
        }
        else if (remainingDots.Length == 0)
        {
            SceneManager.LoadScene(Scenename);
        }
    }

}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **GameMaster 스크립트 제작중 중점 사항**

> 자동차 팩맨 게임의 로직을 담당하는 스크립트입니다.
해당 스크립트를 작성하면서 **List[]** 라는 함수를 처음으로 적용시켜 스크립트를
제작하였습니다. **List[]** 는 배열의 특징을 띄고 있는 함수이지만 배열이 
늘어날때마다 직접 수정해야하는 일반 배열과는 다른 “**동적배열”** 이라고 불리며
이 **“동적배열”** 은 배열의 갯수가 늘어나게 되면 자동적으로 채워지는 배열 
함수입니다. 주로 오브젝트 풀링이나 게임안에서 생성되는 오브젝트가 많을때
사용되는 함수 이며 사용자가 직접 수정할 필요가 없다라는 점에서 아주
메리트가 있는 함수 입니다.
**List[]** 함수를 사용함으로써 게임에 존재하는 **Dot** 이라는 오브젝트를 한번에 관리
할수 있게 됩니다.

또한 **timeLeft -= Time.deltaTime;** 와 **IEnumerator WaitForSceneSwitch()** 
코루틴을 생성하여 **Timer**를 제작하고 지정한 시간이 종료되면 다음 Scene 으로 
넘어갈수 있게 제작하였습니다.

그 다음으로는 **FindGameObjectsWithTag** 를 사용하여 오브젝트의 태그중 **“Dot”**
이라는 태그를 가진 오브젝트의 갯수를 확인하여 **UI** 에 존재하는 기름통의 이미지가 
갯수에 따라 바뀌게 제작하였습니다.
> 
</aside>

### Player

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
public class Player : MonoBehaviour
{
    public float Speed = 1f;
    public int lives = 3;
    public GameObject[] life = new GameObject[3];
    private MeshRenderer playerMeshRenderer;
    public string Scenename;
    void Start()
    {
        playerMeshRenderer = GetComponent<MeshRenderer>();
    }
    private void Update()
    {
        Rigidbody rb = GetComponent<Rigidbody>();
        Vector3 newVelocity = rb.velocity;

        if (Input.GetKey(KeyCode.LeftArrow))
        {
            newVelocity.x = -Speed;
            transform.rotation = Quaternion.Euler(new Vector3(90, 90, -90));
        }
        else if (Input.GetKey(KeyCode.RightArrow))
        {
            newVelocity.x = Speed;
            transform.rotation = Quaternion.Euler(new Vector3(90, 180, 180));
        }
        else
        {
            newVelocity.x = 0;
        }

        if (Input.GetKey(KeyCode.UpArrow))
        {
            newVelocity.y = Speed;
            transform.rotation = Quaternion.Euler(new Vector3(180, 90, -90));
        }
        else if (Input.GetKey(KeyCode.DownArrow))
        {
            newVelocity.y = -Speed;
            transform.rotation = Quaternion.Euler(new Vector3(0, 90, -90));
        }
        else
        {
            newVelocity.y = 0;
        }

        rb.velocity = newVelocity;
    }
    void OnTriggerEnter(Collider other)
    {
        // 유령과 부딪히면 다음 씬으로 이동
        if (other.gameObject.CompareTag("Cloud"))
        {
            lives--;

            if (lives >= 0)
            {
                Destroy(life[lives]);
            }

            if (lives > 0)
            {
                StartCoroutine(FlashRedAndPause());
            }
            else
            {
                SceneManager.LoadScene(Scenename);
            }
        }
    }

    IEnumerator FlashRedAndPause()
    {

        int numFlashes = 3;
        float flashDuration = 0.3f;

        Rigidbody playerRigidbody = GetComponent<Rigidbody>();
        if (playerRigidbody != null) playerRigidbody.velocity = Vector2.zero;

        for (int i = 0; i < numFlashes; i++)
        {
            playerMeshRenderer.enabled = false;
            yield return new WaitForSeconds(flashDuration);
            playerMeshRenderer.enabled = true;
            yield return new WaitForSeconds(flashDuration);
        }
    }
}
```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Player 스크립트 제작중 중점 사항**

> 해당 스크립트는 팩맨 자동차 게임에 사용된 스크립트입니다.
**Input.GetKey** 이라는 함수를 사용하여 체험하는 사용자가 키보드를 사용하여
조작할수 있게 제작하였습니다.
> 
> 
> 앞선 **GameMaster** 스크립트는 게임의 로직을 담당하는 스크립트 이고 
> **Player** 스크립트는 사용자가 플레이하는 **Player** 에 관련된 스크립트 입니다.
> 
> 그리고 **Cloud** 라는 태그를 가진 오브젝트와 3번 **Trigger** 되면 게임 오버됩니다.
> 
> **IEnumerator FlashRedAndPause() 코루틴** 을 생성하여 **Player** 로 지정한 
> 오브젝트가 **Cloud** 라는 태그를 가진 오브젝트와 **Trigger** 된다면 깜빡이는 
> 효과를 설정하였습니다. 
> 
</aside>

### GalagaPlayer

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GalagaPlayer : MonoBehaviour
{
    //공용변수 실수형인 Speed는 0.05f 이다.
    public float Speed = 0.05f;
    //공용변수 게임오브젝트속성인 BulletPrefab를 지정
    public GameObject BulletPrefab;
    public float RightPosition = -11.11f;
    public float MiddlePosition = -11.94f;
    public float LeftPosition = -12.825f;
    //공용변수 위치,회전,크기조정 속성을 가진 BulletPosition를 지정
    public Transform BulletPosition;
    public int lives = 3;
    public GameObject[] life = new GameObject[3];
    private MeshRenderer playerMeshRenderer;
    private bool isSpawning = false;
    public GameObject[] PaperGaze; // 활성화할 오브젝트 배열
    private int activationCount = 0; // 활성화 횟수
    public AudioSource Audio;
    public AudioClip Music;
    public AudioSource Audio2;
    public AudioClip Music2;
    // Start is called before the first frame update

    void Start()
    {
        playerMeshRenderer = GetComponent<MeshRenderer>();
    }
    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.LeftArrow)) // 좌측 방향키를 눌렀을 때
        {
            if (transform.position.x == RightPosition) // 현재 위치가 우측 끝 위치라면
            {
                transform.position = new Vector3(MiddlePosition, transform.position.y, transform.position.z); // 중앙 위치로 이동
            }
            else if (transform.position.x == MiddlePosition) // 현재 위치가 좌측 끝 위치라면
            {
                transform.position = new Vector3(LeftPosition, transform.position.y, transform.position.z); // 좌측 위치로 이동
            }
        }
        if (Input.GetKeyDown(KeyCode.RightArrow)) // 우측 방향키를 눌렀을 때
        {
            if (transform.position.x == MiddlePosition) // 현재 위치가 중앙 위치라면
            {
                transform.position = new Vector3(RightPosition, transform.position.y, transform.position.z); // 우측 끝 위치로 이동
            }
            else if (transform.position.x == LeftPosition) // 현재 위치가 좌측 위치라면
            {
                transform.position = new Vector3(MiddlePosition, transform.position.y, transform.position.z); // 좌측 끝 위치로 이동
            }
        }
        if (Input.GetKeyDown(KeyCode.Space) && !isSpawning)
        {
            StartCoroutine(SpawnAndRotate());
            Audio.PlayOneShot(Music);
        }
    }

    IEnumerator SpawnAndRotate()
    {
        isSpawning = true;
        float randomZRotation = Random.Range(0, 360);

        Vector3 spawnPosition = BulletPosition.position;
        Quaternion fromRotation = Quaternion.Euler(0, 0, 0);
        Quaternion toRotation = Quaternion.Euler(0, 0, randomZRotation);

        float elapsedTime = 0;
        float duration = 0.5f;
        GameObject bulletCopy = Instantiate(BulletPrefab, spawnPosition, fromRotation);

        // Check if bulletCopy is not destroyed
        while (elapsedTime < duration && bulletCopy != null)
        {
            bulletCopy.transform.rotation = Quaternion.Lerp(fromRotation, toRotation, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }

        // Check if bulletCopy is not destroyed
        if (bulletCopy != null)
        {
            bulletCopy.transform.rotation = toRotation;
        }

        isSpawning = false;
    }

    //트리거작동시 호출 명령
    public void OnTriggerEnter(Collider other)
        {
        if (other.gameObject.CompareTag("Tree") || other.gameObject.CompareTag("O2"))
        {
            lives--;

            if (lives >= 0)
            {
                Destroy(life[lives]);
            }

            if (lives > 0)
            {
                StartCoroutine(FlashRedAndPause());
            }
            else
            {
                SceneManager.LoadScene("GalagaLose");
            }
            Destroy(other.gameObject);
        }
        if (other.gameObject.CompareTag("Paper"))
        {
            Audio2.PlayOneShot(Music2);
            Debug.Log("획득");
            Destroy(other.gameObject);
            if (activationCount < PaperGaze.Length) // 배열 범위 확인
            {
                PaperGaze[activationCount].SetActive(true);
                activationCount++;

                if (activationCount >= 5)
                {
                    SceneManager.LoadScene("GalagaWin");
                }
            }
        }
    }

    IEnumerator FlashRedAndPause()
    {

        int numFlashes = 3;
        float flashDuration = 0.3f;

        Rigidbody playerRigidbody = GetComponent<Rigidbody>();
        if (playerRigidbody != null) playerRigidbody.velocity = Vector2.zero;

        for (int i = 0; i < numFlashes; i++)
        {
            playerMeshRenderer.enabled = false;
            yield return new WaitForSeconds(flashDuration);
            playerMeshRenderer.enabled = true;
            yield return new WaitForSeconds(flashDuration);
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **GalagaPlayer 스크립트 제작중 중점 사항**

> 나무 갤러그 게임에서 **Player** 부분에 사용되는 스크립트 입니다.
갤러그 시스템상에서 **Player** 가 **좌 우 로만 움직이는 로직을 구현**하기 위하여
**Update** 함수 안에 **Input.GetKeyDown** 함수를 사용하여 **좌 우 로만 움직일수 있게** 
조작을 구현하였으며 원하는 **Position** 값의 위치로 이동할수 있게 총 3가지의 
**Position** 변수를 설정하였습니다.
> 
> 
> 그리하여 **If** 문으로 감싸 왼쪽 방향키를 눌렀을 시 변수로 지정한 **Right** , **Middle** 
> 변수의 위치값이라면 좌측으로 이동가능하게 반대로 우측 방향키를 눌렀을 시 
> 변수로 지정한 **Left** , **Middle** 변수의 위치값이라면 우측으로 이동할수 있게 
> 제작하였습니다.
> 
> 마지막으로 총알이 발사되어 나무와 트리거 됐을시에 나오는 **O2** 라는 오브젝트와
> **Player** 와 트리거 됐을시 음악재생과 배열 변수로 잡아 놓은 **Papergaze** 안에 
> 오브젝트를 **SetActive** 함수를 통해 활성화를 시키도록 제작하였습니다.
> 
> 그리고 **Papergaze** 의 갯수가 5개에 도달하면 **SceneMove** 함수를 통해 이동하게 
> 제작하는것으로 마무리 하였습니다.
> 
> 또한 **Input.GetKeyDown** 함수를 사용해 **Space** 키를 눌렀을시 0.5초에 한번씩
>  **360 º** 로 돌아가며 발사되는 도끼 총알을 나가게 제작하였습니다. 
> 
> 또한 **Space** 키를 눌렀을시 **Audio.PlayOneShot** 함수를 사용하여 음악이 한번
> 재생되게 제작하였습니다.
> 
</aside>

### GalagaGM

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class GalagaGM : MonoBehaviour
{
    public AudioSource Audio;
    public AudioClip BGM;
    public Text timerText;
    public string Scenename;
    private float timeLeft = 50f;

    void Start()
    {
        StartCoroutine(WaitForSceneSwitch());
        Audio.PlayOneShot(BGM);
        
    }

    void Update()
    {
        UpdateTimer();
    }
    IEnumerator WaitForSceneSwitch()
    {
        yield return new WaitForSeconds(50f);
        SceneManager.LoadScene(Scenename);
    }

    void UpdateTimer()
    {
        timeLeft -= Time.deltaTime;
        if (timeLeft <= 0)
        {
            timeLeft = 0;
        }

        int minutes = (int)(timeLeft / 60);
        int seconds = (int)(timeLeft % 60);
        timerText.text = $"{minutes:00}:{seconds:00}";
    }

}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **GalagaGM 스크립트 제작중 중점 사항**

> 나무 갤러그 게임에 사용되는 스크립트 입니다.
> 
> 
> **TImer** , **BGM** 을 담당해주는 스크립트이며 게임이 시작되면 **BGM**을 재생시키고 **StartCoroutine** 함수를 통해 **Timer** 가 재생되게 제작하였습니다. 
> 
> 자동차 팩맨과 마찬가지로 시간이 종료되면 지정한 **Scene** 으로 이동할수 있게 
> 제작하였습니다.
> 
</aside>

### SpawnTree

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SpawnTree : MonoBehaviour
{
    public GameObject Tree;
    public Transform[] spawnPoints; // 생성 위치 배열
    public float moveSpeed = 2f;    // 이동 속도
    public int BulletMinTime = 60;
    //공변수 BulletMaxTime의 값은 180
    public int BulletMaxTime = 180;
    public GameObject Bubble; // 공기 방울 프리팹
    public AudioSource Audio;
    public AudioClip Music;

    void Start()
    {
        // 3초마다 Generate() 메소드 호출
        InvokeRepeating("Generate", 0f, 3f);
    }

    void Generate()
    {
        // 랜덤한 위치에서 오브젝트 생성
        int index = Random.Range(0, 3);
        Transform spawnPoint = spawnPoints[index];
        GameObject Trees = Instantiate(Tree, spawnPoint.position, Quaternion.identity);
        StartCoroutine(ShootBubble(Trees.transform));
        // 생성된 오브젝트 이동
        Vector3 moveDirection = Vector3.down;
        Trees.GetComponent<Rigidbody>().velocity = moveDirection * moveSpeed;
        
    }

    IEnumerator ShootBubble(Transform treeTransform)
    {
        
        // 발사 지연 시간 설정
        float delay = Random.Range(BulletMinTime, BulletMaxTime) / 100f;
        yield return new WaitForSeconds(delay);
        if (treeTransform == null)
        {
            yield break;
        }
        // 생성된 오브젝트 앞부분 위치
        float forwardOffset = 0.5f;
        Vector3 bulletPos = treeTransform.position + new Vector3(0, -forwardOffset, 0);

        // 공기 방울 생성
        GameObject bubbleInstance = Instantiate(Bubble, bulletPos, Quaternion.identity);
        Audio.PlayOneShot(Music);

        // 공기 방울 생성 후 1초 후 삭제
        Destroy(bubbleInstance, 1f);
    }

}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **SpawnTree 스크립트 제작중 중점 사항**

> 나무 갤러그 게임에서 **Tree** 라는 오브젝트를 관리해주는 스크립트 입니다.
먼저 생성위치를 배열을 통해 3가지 위치에 지정한 뒤 게임 시작시
**InvokeRepeating** 함수를 사용하여 3초마다 랜덤한 위치에 **Tree** 오브젝트를 
생성합니다.
> 
> 
> ---
> 
> **Generate** 로직
> 
> > **1. int index = Random.Range(0, 3);** 에서  **Random.Range**를 통해 3가지를
>    랜덤으로 **index** 라는 변수에 집어 넣습니다.
> > 
> > 
> > **2.** 이러한 **index** 라는 변수는 **spawnPoints** 라는 배열안에 들어가게 됩니다.
> > 
> > **3.** **Trees** 오브젝트는 **Instantiate** 함수 ****를 통해 미리 지정한 **spawnPoint**
> >    위치값에서 생성됩니다.
> > 
> > **4.** 생성이 된 뒤에 **Vector3 moveDirection = Vector3.down;** 를 통해 아래로 
> >    이동하게 됩니다. 
> > 
> >    이 부분에서 **Trees** 오브젝트는 **Rigidbody** 속성을 받아
> >    **moveDirection * moveSpeed** 값만큼 아래로 이동하게 됩니다.
> > 
> 
> ---
> 
> 그다음 생성된 **Tree** 오브젝트들은 **Generate** 함수에 포함되어있는 **ShootBubble**
> 코루틴 함수를 실행하게 됩니다. 
> 
> 이러한 로직은 생성된 **Tree** 오브젝트들이 **O2** 오브젝트를 발사하기 위한 로직이며 
> 이렇게 생성된 **O2** 오브젝트는 앞서 설명 드렸던 **GalagaPlayer** 가 적용된 오브젝트와 상호 작용하여 트리거 됐을시 **GalagaPlayer** 에서 생성하였던 **Life** 시스템과 
> 상호 작용하여 라이프 시스템을구축하게 제작하였습니다.
> 
</aside>

